use std::io;

use crate::codegen::{Exporter, LanguageGenerator};
use crate::compiler::VERSION;
use crate::error::{Err, Result};
use crate::parser::ast::*;

pub struct Generator;

impl LanguageGenerator for Generator {
    fn generate<W: io::Write>(writer: &mut W, ast: &Ast) -> Result<()> {
        ast.generate(writer).map_err(Err::CodeGen)?;
        Ok(())
    }
}

impl Exporter for Generator {
    fn export<W: io::Write>(writer: &mut W, mod_name: &str) -> Result<()> {
        writeln!(writer, "pub mod {};", mod_name).map_err(Err::IOError)?;
        Ok(())
    }
}

trait Generate {
    type Out;

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out>;
}

impl Generate for Ast {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        writeln!(writer, "// Generated by Binserde {}\n", VERSION)?;
        writeln!(writer, "use bincode::{{error, Decode, Encode}};")?;
        writeln!(writer, "use bincode_macro::Serde;\n")?;

        for decl in &self.decls {
            decl.generate(writer)?;
        }

        Ok(())
    }
}

impl Generate for Decl {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        match self {
            Decl::Struct(s) => s.generate(writer),
        }
    }
}

impl Generate for Struct {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        writeln!(
            writer,
            "#[derive(Serde, Encode, Decode, PartialEq, Clone, Debug, Default)]"
        )?;
        writeln!(writer, "pub struct {} {{", self.id)?;
        for field in &self.fields {
            writeln!(writer, "\tpub {}: {},", field.id, field.type_.generate_rs())?;
        }
        writeln!(writer, "}}")?;
        Ok(())
    }
}

impl Type {
    fn generate_rs(&self) -> &str {
        match self {
            Type::Bool => "bool",
            Type::Uint8 => "u8",
            Type::Uint16 => "u16",
            Type::Uint32 => "u32",
            Type::Uint64 => "u64",
            Type::Uint128 => "u128",
            Type::Int8 => "i8",
            Type::Int16 => "i16",
            Type::Int32 => "i32",
            Type::Int64 => "i64",
            Type::Int128 => "i128",
            Type::Float32 => "f32",
            Type::Float64 => "f64",
            Type::String => "String",
        }
    }
}
