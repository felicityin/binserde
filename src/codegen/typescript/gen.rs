use std::io;

use crate::codegen::{Exporter, LanguageGenerator};
use crate::compiler::VERSION;
use crate::error::{Err, Result};
use crate::parser::ast::*;

pub struct Generator;

impl LanguageGenerator for Generator {
    fn generate<W: io::Write>(writer: &mut W, ast: &Ast) -> Result<()> {
        ast.generate(writer).map_err(Err::CodeGen)?;
        Ok(())
    }
}

impl Exporter for Generator {
    fn export<W: io::Write>(writer: &mut W, lib_name: &str) -> Result<()> {
        writeln!(writer, "export * from './{}';", lib_name).map_err(Err::IOError)?;
        Ok(())
    }
}

pub trait Generate {
    type Out;

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out>;
}

impl Generate for Ast {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        writeln!(writer, "// Generated by Binserde {}\n", VERSION)?;
        writeln!(writer, "import {{ Base, Bool, Int8, Int16, Int32, Int64, Int128, Option, String, Uint8, Uint16, Uint32, Uint64, Uint128, Float32, Float64, Vec }} from 'bincoder';\n")?;

        for decl in &self.decls {
            decl.generate(writer)?;
        }

        Ok(())
    }
}

impl Generate for Decl {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        match self {
            Decl::Struct(s) => s.generate(writer),
        }
    }
}

impl Generate for Struct {
    type Out = ();

    fn generate<W: io::Write>(&self, writer: &mut W) -> io::Result<Self::Out> {
        writeln!(writer, "export class {} extends Base {{", self.id)?;
        for field in &self.fields {
            writeln!(writer, "  {}: {};", field.id, field.type_.generate_ts())?;
        }

        write!(writer, "\n  constructor(")?;
        for (i, field) in self.fields.iter().enumerate() {
            let t = field.type_.generate_ts();
            if i < self.fields.len() - 1 {
                write!(writer, "{}: {} = new {}(), ", field.id, t, t)?;
            } else {
                write!(writer, "{}: {} = new {}()", field.id, t, t)?;
            }
        }
        writeln!(writer, ") {{")?;

        writeln!(writer, "    super()")?;

        for field in &self.fields {
            writeln!(writer, "    this.{} = {};", field.id, field.id)?;
        }
        writeln!(writer, "  }}")?;

        writeln!(writer, "}}")?;
        Ok(())
    }
}

impl Type {
    fn generate_ts(&self) -> &str {
        match self {
            Type::Bool => "Bool",
            Type::Uint8 => "Uint8",
            Type::Uint16 => "Uint16",
            Type::Uint32 => "Uint32",
            Type::Uint64 => "Uint64",
            Type::Uint128 => "Uint128",
            Type::Int8 => "Int8",
            Type::Int16 => "Int16",
            Type::Int32 => "Int32",
            Type::Int64 => "Int64",
            Type::Int128 => "Int128",
            Type::Float32 => "Float32",
            Type::Float64 => "Float64",
            Type::String => "String",
        }
    }
}
